<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Simulator - Bybit-style Futures Trading</title>
    <style>
        :root {
            --primary: #1E2329;
            --secondary: #252930;
            --accent: #F0B90B;
            --text: #F8F9FA;
            --text-secondary: #848E9C;
            --green: #02C076;
            --red: #F6465D;
            --border: #343A40;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--primary);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background-color: var(--secondary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        .user-balance {
            display: flex;
            gap: 1rem;
        }
        
        .balance-item {
            background-color: var(--primary);
            padding: 0.5rem 1rem;
            border-radius: 4px;
        }
        
        .balance-item .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .balance-item .value {
            font-weight: bold;
        }
        
        .main-content {
            display: flex;
            flex: 1;
        }
        
        .chart-container {
            flex: 1;
            padding: 1rem;
            border-right: 1px solid var(--border);
            min-height: 500px;
            overflow: hidden;
        }
        
        .chart {
            width: 100%;
            height: 400px;
            background-color: var(--secondary);
            overflow: hidden;
            position: relative;
        }
        
        .chart canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        .chart canvas:active {
            cursor: grabbing;
        }
        
        .price-info {
            display: flex;
            margin-top: 0.5rem;
            gap: 1rem;
        }
        
        .price-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .price-value {
            font-weight: bold;
        }
        
        .up {
            color: var(--green);
        }
        
        .down {
            color: var(--red);
        }
        
        .trading-panel {
            width: 350px;
            background-color: var(--secondary);
            padding: 1rem;
            border-left: 1px solid var(--border);
        }
        
        .panel-tabs {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: var(--text-secondary);
        }
        
        .tab.active {
            color: var(--accent);
            border-bottom: 2px solid var(--accent);
        }
        
        .form-group {
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        input, select {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 1rem;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .leverage-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .leverage-option {
            padding: 0.5rem;
            background-color: var(--primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            flex: 1;
        }
        
        .leverage-option.active {
            background-color: var(--accent);
            color: var(--primary);
        }
        
        .button-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }
        
        .btn {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .btn-buy {
            background-color: var(--green);
            color: white;
        }
        
        .btn-sell {
            background-color: var(--red);
            color: white;
        }
        
        .order-book-container {
            margin-top: 2rem;
        }
        
        .order-book-title {
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        
        .order-book {
            background-color: var(--primary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .order-header {
            display: flex;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .order-book-column {
            flex: 1;
            text-align: right;
        }
        
        .order-book-column:first-child {
            text-align: left;
        }
        
        .ask, .bid {
            display: flex;
            padding: 0.5rem;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border);
        }
        
        .ask {
            color: var(--red);
        }
        
        .bid {
            color: var(--green);
        }
        
        .order-volume {
            position: relative;
        }
        
        .volume-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            z-index: 0;
            opacity: 0.2;
        }
        
        .ask .volume-bar {
            background-color: var(--red);
        }
        
        .bid .volume-bar {
            background-color: var(--green);
        }
        
        .positions-container {
            margin-top: 2rem;
        }
        
        .positions-title {
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        
        .position {
            background-color: var(--primary);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .position-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .position-symbol {
            font-weight: bold;
        }
        
        .position-type {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .position-type.long {
            background-color: rgba(2, 192, 118, 0.2);
            color: var(--green);
        }
        
        .position-type.short {
            background-color: rgba(246, 70, 93, 0.2);
            color: var(--red);
        }
        
        .position-details {
            display: flex;
            font-size: 0.9rem;
            color: var(--text-secondary);
            gap: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .position-pnl {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .close-position {
            background-color: var(--border);
            border: none;
            color: var(--text);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .no-position {
            color: var(--text-secondary);
            text-align: center;
            padding: 1rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 999;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: var(--secondary);
            width: 400px;
            border-radius: 8px;
            padding: 1.5rem;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .settings-group {
            margin-bottom: 1.5rem;
        }
        
        .settings-title {
            margin-bottom: 0.5rem;
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .api-note {
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: rgba(240, 185, 11, 0.1);
            border-left: 3px solid var(--accent);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .btn-save {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--accent);
            color: var(--primary);
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }
            
            .trading-panel {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        .timeframe-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .timeframe-btn {
            padding: 0.5rem 1rem;
            background-color: var(--primary);
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            border-radius: 4px;
        }

        .timeframe-btn.active {
            background-color: var(--accent);
            color: var(--primary);
        }

        .chart-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .chart-btn {
            background-color: var(--secondary);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .chart-btn:hover {
            background-color: var(--accent);
            color: var(--primary);
        }
        
        .debug-info {
            margin-left: auto;
            font-size: 0.9rem;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
        }

        .chart {
            position: relative;
            overflow: hidden;
        }
        
        .chart-crosshair-v,
        .chart-crosshair-h {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            display: none;
        }
        
        .chart-crosshair-v {
            width: 1px;
            height: 100%;
            top: 0;
        }
        
        .chart-crosshair-h {
            height: 1px;
            width: 100%;
            left: 0;
        }
        
        .chart-price-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">TradeSim</div>
        <div class="user-balance">
            <div class="balance-item">
                <div class="label">Balance</div>
                <div class="value" id="user-balance">$10,000.00</div>
            </div>
            <div class="balance-item">
                <div class="label">Available</div>
                <div class="value" id="available-balance">$10,000.00</div>
            </div>
            <button id="settings-btn" class="balance-item">
                <div class="label">Settings</div>
            </button>
        </div>
    </div>
    
    <div class="main-content">
        <div class="chart-container">
            <div class="symbol-selector">
                <select id="trading-pair">
                    <option value="BTCUSDT">BTC/USDT</option>
                    <option value="ETHUSDT">ETH/USDT</option>
                    <option value="SOLUSDT">SOL/USDT</option>
                    <option value="BNBUSDT">BNB/USDT</option>
                    <option value="XRPUSDT">XRP/USDT</option>
                    <option value="ADAUSDT">ADA/USDT</option>
                    <option value="DOTUSDT">DOT/USDT</option>
                    <option value="DOGEUSDT">DOGE/USDT</option>
                    <option value="MATICUSDT">MATIC/USDT</option>
                    <option value="LINKUSDT">LINK/USDT</option>
                </select>
            </div>
            <div class="timeframe-selector">
                <button class="timeframe-btn active" data-timeframe="15m">15m</button>
                <button class="timeframe-btn" data-timeframe="30m">30m</button>
                <button class="timeframe-btn" data-timeframe="1h">1h</button>
                <button class="timeframe-btn" data-timeframe="4h">4h</button>
                <button class="timeframe-btn" data-timeframe="1d">1d</button>
            </div>
            <div class="chart-controls">
                <button id="zoom-in" class="chart-btn">+</button>
                <button id="zoom-out" class="chart-btn">-</button>
                <button id="reset-zoom" class="chart-btn">Reset</button>
                <button id="draw-trendline" class="chart-btn">Draw Trendline</button>
                <div class="debug-info" id="debug-info">Price: $0</div>
            </div>
            <div class="chart" id="price-chart">
                <canvas id="chart-canvas"></canvas>
            </div>
            <div class="price-info">
                <div>
                    <div class="price-label">Last Price</div>
                    <div class="price-value up" id="current-price">$45,678.90</div>
                </div>
                <div>
                    <div class="price-label">24h Change</div>
                    <div class="price-value up" id="price-change">+2.34%</div>
                </div>
                <div>
                    <div class="price-label">24h High</div>
                    <div class="price-value" id="price-high">$46,123.45</div>
                </div>
                <div>
                    <div class="price-label">24h Low</div>
                    <div class="price-value" id="price-low">$44,789.12</div>
                </div>
                <div>
                    <div class="price-label">24h Volume</div>
                    <div class="price-value" id="volume">$1.23B</div>
                </div>
            </div>
        </div>
        
        <div class="trading-panel">
            <div class="panel-tabs">
                <div class="tab active" data-tab="market">Market</div>
                <div class="tab" data-tab="limit">Limit</div>
                <div class="tab" data-tab="conditional">Conditional</div>
            </div>
            
            <div class="order-form">
                <div class="form-group">
                    <label for="order-type">Order Type</label>
                    <select id="order-type">
                        <option value="market">Market</option>
                        <option value="limit">Limit</option>
                        <option value="conditional">Conditional</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="leverage">Leverage</label>
                    <div class="leverage-selector">
                        <div class="leverage-option" data-leverage="1">1x</div>
                        <div class="leverage-option" data-leverage="5">5x</div>
                        <div class="leverage-option active" data-leverage="10">10x</div>
                        <div class="leverage-option" data-leverage="20">20x</div>
                        <div class="leverage-option" data-leverage="50">50x</div>
                    </div>
                    <input type="range" id="leverage-slider" min="1" max="100" value="10">
                </div>
                
                <div class="form-group">
                    <label for="order-size">Order Size (USDT)</label>
                    <input type="number" id="order-size" placeholder="Enter amount" value="100">
                </div>
                
                <div class="form-group" id="limit-price-container" style="display: none;">
                    <label for="limit-price">Limit Price (USDT)</label>
                    <input type="number" id="limit-price" placeholder="Enter price">
                </div>
                
                <div class="form-group" id="trigger-price-container" style="display: none;">
                    <label for="trigger-price">Trigger Price (USDT)</label>
                    <input type="number" id="trigger-price" placeholder="Enter trigger price">
                </div>
                
                <div class="button-group">
                    <button class="btn btn-buy" id="buy-btn">Buy/Long</button>
                    <button class="btn btn-sell" id="sell-btn">Sell/Short</button>
                </div>
            </div>
            
            <div class="order-book-container">
                <div class="order-book-title">Order Book</div>
                <div class="order-book">
                    <div class="order-header">
                        <div class="order-book-column">Price (USDT)</div>
                        <div class="order-book-column">Size (BTC)</div>
                        <div class="order-book-column">Total</div>
                    </div>
                    <div id="asks-container">
                    </div>
                    <div id="bids-container">
                    </div>
                </div>
            </div>
            
            <div class="positions-container">
                <div class="positions-title">Positions</div>
                <div id="positions-container">
                    <div class="no-position" id="no-positions-message">No open positions</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <button class="close-modal">×</button>
            </div>
            
            <div class="settings-group">
                <div class="settings-title">Initial Balance</div>
                <input type="number" id="initial-balance" value="10000">
            </div>
            
            <div class="settings-group">
                <div class="settings-title">Price Update Interval</div>
                <select id="price-update-interval">
                    <option value="10000">10 seconds</option>
                    <option value="15000" selected>15 seconds</option>
                    <option value="30000">30 seconds</option>
                    <option value="60000">60 seconds</option>
                </select>
            </div>
            
            <div class="settings-group">
                <div class="settings-title">Market Volatility</div>
                <select id="market-volatility">
                    <option value="0.5">Low</option>
                    <option value="1" selected>Normal</option>
                    <option value="2">High</option>
                </select>
            </div>
            
            <div class="api-note">
                Note: This simulator uses the free CoinGecko API which has rate limits. 
                Please keep the update interval to at least 10 seconds to avoid hitting rate limits.
            </div>
            
            <button class="btn-save" id="save-settings">Save Changes</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            initChart();
            await fetchHistoricalData();
            await fetchCurrentPrice();
            startPriceUpdates();
            initEnhancedChart();
            addCrosshairTracking();
        });
        
        let currentPrice = 45000;
        let initialBalance = 10000;
        let userBalance = initialBalance;
        let availableBalance = initialBalance;
        let currentLeverage = 10;
        let positions = [];
        let priceHistory = [];
        let orderBook = [];
        let selectedPair = 'bitcoin';
        let displayPair = 'BTCUSDT';
        let orderType = 'market';
        let updateInterval = 15000;
        let volatilityMultiplier = 1.0;
        let priceUpdateInterval;
        let chartContext;
        let historicalDataLoaded = false;
        let rawPriceData = [];
        let currentTimeframe = '15m';
        let trendlines = [];
        let tempTrendline = null;
        let isDrawingTrendline = false;
        
        const COINGECKO_API = {
            PRICE: 'https://api.coingecko.com/api/v3/simple/price',
            COINS: 'https://api.coingecko.com/api/v3/coins/list',
            MARKET_CHART: 'https://api.coingecko.com/api/v3/coins/{id}/market_chart',
            COIN_DATA: 'https://api.coingecko.com/api/v3/coins/{id}'
        };
        
        const TRADING_PAIRS = {
            'BTCUSDT': 'bitcoin',
            'ETHUSDT': 'ethereum',
            'SOLUSDT': 'solana',
            'BNBUSDT': 'binancecoin',
            'XRPUSDT': 'ripple',
            'ADAUSDT': 'cardano',
            'DOTUSDT': 'polkadot',
            'DOGEUSDT': 'dogecoin',
            'MATICUSDT': 'matic-network',
            'LINKUSDT': 'chainlink'
        };
        
        const COINGECKO_TO_PAIR = {};
        Object.keys(TRADING_PAIRS).forEach(pair => {
            COINGECKO_TO_PAIR[TRADING_PAIRS[pair]] = pair;
        });
        
        const userBalanceElement = document.getElementById('user-balance');
        const availableBalanceElement = document.getElementById('available-balance');
        const currentPriceElement = document.getElementById('current-price');
        const priceChangeElement = document.getElementById('price-change');
        const priceHighElement = document.getElementById('price-high');
        const priceLowElement = document.getElementById('price-low');
        const volumeElement = document.getElementById('volume');
        const leverageOptions = document.querySelectorAll('.leverage-option');
        const leverageSlider = document.getElementById('leverage-slider');
        const orderSizeInput = document.getElementById('order-size');
        const limitPriceInput = document.getElementById('limit-price');
        const triggerPriceInput = document.getElementById('trigger-price');
        const limitPriceContainer = document.getElementById('limit-price-container');
        const triggerPriceContainer = document.getElementById('trigger-price-container');
        const buyButton = document.getElementById('buy-btn');
        const sellButton = document.getElementById('sell-btn');
        const tradingPairSelect = document.getElementById('trading-pair');
        const orderTypeSelect = document.getElementById('order-type');
        const positionsContainer = document.getElementById('positions-container');
        const noPositionsMessage = document.getElementById('no-positions-message');
        const asksContainer = document.getElementById('asks-container');
        const bidsContainer = document.getElementById('bids-container');
        const settingsButton = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalButton = document.querySelector('.close-modal');
        const saveSettingsButton = document.getElementById('save-settings');
        const initialBalanceInput = document.getElementById('initial-balance');
        const priceUpdateIntervalSelect = document.getElementById('price-update-interval');
        const marketVolatilitySelect = document.getElementById('market-volatility');
        const orderTabs = document.querySelectorAll('.tab');
        const chartCanvas = document.getElementById('chart-canvas');
        const timeframeButtons = document.querySelectorAll('.timeframe-btn');
        const drawTrendlineBtn = document.getElementById('draw-trendline');
        
        function initChart() {
            chartContext = chartCanvas.getContext('2d');
            chartCanvas.width = chartCanvas.offsetWidth;
            chartCanvas.height = chartCanvas.offsetHeight;
            drawChart();
        }
        
        function drawChart() {
            const ctx = chartContext;
            const width = chartCanvas.width;
            const height = chartCanvas.height;
            ctx.clearRect(0, 0, width, height);
            
            if (!priceHistory.length) return;
            
            const startIdx = Math.max(0, priceHistory.length - visibleDataPoints - panOffsetX);
            const endIdx = Math.min(priceHistory.length, startIdx + visibleDataPoints);
            const visiblePrices = priceHistory.slice(startIdx, endIdx);
            
            if (!visiblePrices.length) return;
            
            const minPrice = Math.min(...visiblePrices.map(p => p.low)) * 0.999;
            const maxPrice = Math.max(...visiblePrices.map(p => p.high)) * 1.001;
            const priceRange = maxPrice - minPrice;
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = Math.floor(height * (i / 5));
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                const price = maxPrice - (i / 5) * priceRange;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(price.toFixed(2), 5, y - 5);
            }
            const timeStep = Math.max(1, Math.floor(visiblePrices.length / 10));
            for (let i = 0; i < visiblePrices.length; i += timeStep) {
                const x = Math.floor(width * (i / visiblePrices.length));
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }
            ctx.stroke();
            
            const barWidth = width / visiblePrices.length;
            visiblePrices.forEach((price, index) => {
                const x = index * barWidth;
                const openY = height - (price.open - minPrice) / priceRange * height;
                const closeY = height - (price.close - minPrice) / priceRange * height;
                const highY = height - (price.high - minPrice) / priceRange * height;
                const lowY = height - (price.low - minPrice) / priceRange * height;
                const isBullish = price.close > price.open;
                ctx.fillStyle = isBullish ? '#02C076' : '#F6465D';
                ctx.strokeStyle = ctx.fillStyle;
                ctx.beginPath();
                ctx.moveTo(x + barWidth / 2, highY);
                ctx.lineTo(x + barWidth / 2, lowY);
                ctx.stroke();
                const bodyHeight = Math.abs(closeY - openY);
                const bodyY = Math.min(openY, closeY);
                ctx.fillRect(x + barWidth * 0.2, bodyY, barWidth * 0.6, bodyHeight);
            });
            
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            trendlines.forEach(trendline => {
                const startCoords = getCanvasCoordinates(trendline.start.timestamp, trendline.start.price);
                const endCoords = getCanvasCoordinates(trendline.end.timestamp, trendline.end.price);
                if (startCoords && endCoords) {
                    ctx.beginPath();
                    ctx.moveTo(startCoords.x, startCoords.y);
                    ctx.lineTo(endCoords.x, endCoords.y);
                    ctx.stroke();
                }
            });
            
            if (tempTrendline) {
                const startCoords = getCanvasCoordinates(tempTrendline.start.timestamp, tempTrendline.start.price);
                const endCoords = getCanvasCoordinates(tempTrendline.end.timestamp, tempTrendline.end.price);
                if (startCoords && endCoords) {
                    ctx.beginPath();
                    ctx.moveTo(startCoords.x, startCoords.y);
                    ctx.lineTo(endCoords.x, endCoords.y);
                    ctx.stroke();
                }
            }
        }
        
        async function fetchCurrentPrice() {
            try {
                const params = new URLSearchParams({
                    ids: selectedPair,
                    vs_currencies: 'usd',
                    include_24hr_change: 'true',
                    include_24hr_vol: 'true',
                    include_market_cap: 'true',
                    include_24h_high: 'true',
                    include_24h_low: 'true'
                });
                const response = await fetch(`${COINGECKO_API.PRICE}?${params.toString()}`);
                if (!response.ok) {
                    simulatePriceMovement();
                    return;
                }
                const data = await response.json();
                if (data[selectedPair]) {
                    const previousPrice = currentPrice;
                    currentPrice = data[selectedPair].usd;
                    updatePriceUI(data[selectedPair], previousPrice);
                } else {
                    simulatePriceMovement();
                }
            } catch (error) {
                console.error('Error fetching price:', error);
                simulatePriceMovement();
            }
        }
        
        function simulatePriceMovement() {
            const previousPrice = currentPrice;
            const changePercent = (Math.random() * 0.02 - 0.01) * volatilityMultiplier;
            currentPrice = currentPrice * (1 + changePercent);
            const open = previousPrice;
            const close = currentPrice;
            const high = Math.max(open, close) * (1 + Math.random() * 0.005);
            const low = Math.min(open, close) * (1 - Math.random() * 0.005);
            priceHistory.push({ open, high, low, close, timestamp: Date.now() });
            if (priceHistory.length > 300) priceHistory.shift();
            const high24h = Math.max(...priceHistory.map(p => p.high));
            const low24h = Math.min(...priceHistory.map(p => p.low));
            const priceStart = priceHistory[0].open;
            const priceChange = ((currentPrice - priceStart) / priceStart) * 100;
            currentPriceElement.textContent = `${currentPrice.toFixed(2)}`;
            if (currentPrice > previousPrice) {
                currentPriceElement.className = 'price-value up';
            } else if (currentPrice < previousPrice) {
                currentPriceElement.className = 'price-value down';
            } else {
                currentPriceElement.className = 'price-value';
            }
            priceHighElement.textContent = `${high24h.toFixed(2)}`;
            priceLowElement.textContent = `${low24h.toFixed(2)}`;
            priceChangeElement.textContent = `${priceChange.toFixed(2)}%`;
            priceChangeElement.className = priceChange > 0 ? 'price-value up' : priceChange < 0 ? 'price-value down' : 'price-value';
            drawChart();
        }

        function updatePriceUI(priceData, previousPrice) {
            currentPriceElement.textContent = `${currentPrice.toFixed(2)}`;
            currentPriceElement.className = currentPrice > previousPrice ? 'price-value up' : currentPrice < previousPrice ? 'price-value down' : 'price-value';
            priceHighElement.textContent = `${priceData.high_24h.toFixed(2)}`;
            priceLowElement.textContent = `${priceData.low_24h.toFixed(2)}`;
            priceChangeElement.textContent = `${priceData.price_change_percentage_24h.toFixed(2)}%`;
            priceChangeElement.className = priceData.price_change_percentage_24h > 0 ? 'price-value up' : priceData.price_change_percentage_24h < 0 ? 'price-value down' : 'price-value';
        }
        
        async function fetchHistoricalData() {
            try {
                const response = await fetch(COINGECKO_API.MARKET_CHART.replace('{id}', selectedPair) + '?vs_currency=usd&days=1');
                if (!response.ok) throw new Error('Failed to fetch historical data');
                const data = await response.json();
                rawPriceData = data.prices;
                updateChartData();
                historicalDataLoaded = true;
            } catch (error) {
                console.error('Error fetching historical data:', error);
                priceHistory = generateCandlestickData(currentPrice);
                historicalDataLoaded = true;
                drawChart();
            }
        }
        
        function aggregateOHLC(timeframe) {
            const intervalMinutes = parseTimeframe(timeframe);
            const intervalMs = intervalMinutes * 60 * 1000;
            const ohlcData = [];
            let currentOhlc = null;
            let currentStart = rawPriceData[0][0] - (rawPriceData[0][0] % intervalMs);
            rawPriceData.forEach(([timestamp, price]) => {
                while (timestamp >= currentStart + intervalMs) {
                    if (currentOhlc) ohlcData.push(currentOhlc);
                    currentStart += intervalMs;
                    currentOhlc = null;
                }
                if (!currentOhlc) {
                    currentOhlc = { open: price, high: price, low: price, close: price, timestamp: currentStart };
                } else {
                    currentOhlc.high = Math.max(currentOhlc.high, price);
                    currentOhlc.low = Math.min(currentOhlc.low, price);
                    currentOhlc.close = price;
                }
            });
            if (currentOhlc) ohlcData.push(currentOhlc);
            return ohlcData;
        }
        
        function parseTimeframe(timeframe) {
            const match = timeframe.match(/^(\d+)([mdh])$/);
            if (!match) return 1;
            const value = parseInt(match[1]);
            const unit = match[2];
            if (unit === 'm') return value;
            if (unit === 'h') return value * 60;
            if (unit === 'd') return value * 1440;
            return 1;
        }
        
        function updateChartData() {
            priceHistory = aggregateOHLC(currentTimeframe);
            drawChart();
        }
        
        settingsButton.addEventListener('click', () => {
            settingsModal.style.display = 'flex';
        });
        
        closeModalButton.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });
        
        saveSettingsButton.addEventListener('click', () => {
            initialBalance = parseFloat(initialBalanceInput.value) || initialBalance;
            userBalance = initialBalance;
            availableBalance = initialBalance;
            userBalanceElement.textContent = `$${userBalance.toFixed(2)}`;
            availableBalanceElement.textContent = `$${availableBalance.toFixed(2)}`;
            updateInterval = parseInt(priceUpdateIntervalSelect.value, 10) || updateInterval;
            volatilityMultiplier = parseFloat(marketVolatilitySelect.value) || volatilityMultiplier;
            settingsModal.style.display = 'none';
            clearInterval(priceUpdateInterval);
            priceUpdateInterval = setInterval(fetchCurrentPrice, updateInterval);
        });
        
        orderTypeSelect.addEventListener('change', (event) => {
            orderType = event.target.value;
            limitPriceContainer.style.display = orderType === 'limit' || orderType === 'conditional' ? 'block' : 'none';
            triggerPriceContainer.style.display = orderType === 'conditional' ? 'block' : 'none';
        });
        
        leverageOptions.forEach(option => {
            option.addEventListener('click', () => {
                leverageOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                currentLeverage = parseInt(option.dataset.leverage);
                leverageSlider.value = currentLeverage;
            });
        });
        
        leverageSlider.addEventListener('input', (event) => {
            currentLeverage = parseInt(event.target.value);
            leverageOptions.forEach(opt => opt.classList.remove('active'));
            leverageOptions.forEach(opt => {
                if (parseInt(opt.dataset.leverage) === currentLeverage) opt.classList.add('active');
            });
        });
        
        tradingPairSelect.addEventListener('change', async (event) => {
            selectedPair = TRADING_PAIRS[event.target.value];
            displayPair = event.target.value;
            priceHistory = [];
            historicalDataLoaded = false;
            await fetchHistoricalData();
            await fetchCurrentPrice();
        });
        
        buyButton.addEventListener('click', () => placeOrder('buy'));
        sellButton.addEventListener('click', () => placeOrder('sell'));
        
        timeframeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                timeframeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTimeframe = btn.dataset.timeframe;
                updateChartData();
            });
        });
        
        drawTrendlineBtn.addEventListener('click', () => {
            isDrawingTrendline = !isDrawingTrendline;
            drawTrendlineBtn.classList.toggle('active', isDrawingTrendline);
        });
        
        chartCanvas.addEventListener('mousedown', (e) => {
            if (isDrawingTrendline) {
                const { timestamp, price } = getDataCoordinates(e);
                tempTrendline = { start: { timestamp, price }, end: { timestamp, price } };
            } else {
                isPanning = true;
                lastMouseX = e.clientX;
                chartCanvas.style.cursor = 'grabbing';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDrawingTrendline && tempTrendline) {
                const { timestamp, price } = getDataCoordinates(e);
                tempTrendline.end = { timestamp, price };
                drawChart();
            } else if (isPanning) {
                const dx = e.clientX - lastMouseX;
                lastMouseX = e.clientX;
                panOffsetX = Math.max(0, panOffsetX - dx / 5);
                drawChart();
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDrawingTrendline && tempTrendline) {
                trendlines.push(tempTrendline);
                tempTrendline = null;
                isDrawingTrendline = false;
                drawTrendlineBtn.classList.remove('active');
                drawChart();
            } else {
                isPanning = false;
                chartCanvas.style.cursor = 'grab';
            }
        });
        
        function getDataCoordinates(e) {
            const rect = chartCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const width = chartCanvas.width;
            const height = chartCanvas.height;
            const startIdx = Math.max(0, priceHistory.length - visibleDataPoints - panOffsetX);
            const endIdx = Math.min(priceHistory.length, startIdx + visibleDataPoints);
            const visiblePrices = priceHistory.slice(startIdx, endIdx);
            if (!visiblePrices.length) return { timestamp: 0, price: 0 };
            const fractionalIndex = (x / width) * (visiblePrices.length - 1);
            const index1 = Math.floor(fractionalIndex);
            const index2 = Math.min(index1 + 1, visiblePrices.length - 1);
            const alpha = fractionalIndex - index1;
            const timestamp1 = visiblePrices[index1].timestamp;
            const timestamp2 = visiblePrices[index2].timestamp;
            const timestamp = timestamp1 + alpha * (timestamp2 - timestamp1);
            const minPrice = Math.min(...visiblePrices.map(p => p.low));
            const maxPrice = Math.max(...visiblePrices.map(p => p.high));
            const priceRange = maxPrice - minPrice;
            const price = maxPrice - (y / height) * priceRange;
            return { timestamp, price };
        }
        
        function getCanvasCoordinates(timestamp, price) {
            const width = chartCanvas.width;
            const height = chartCanvas.height;
            const startIdx = Math.max(0, priceHistory.length - visibleDataPoints - panOffsetX);
            const endIdx = Math.min(priceHistory.length, startIdx + visibleDataPoints);
            const visiblePrices = priceHistory.slice(startIdx, endIdx);
            if (!visiblePrices.length) return null;
            const firstTimestamp = visiblePrices[0].timestamp;
            const lastTimestamp = visiblePrices[visiblePrices.length - 1].timestamp;
            const xFraction = (timestamp - firstTimestamp) / (lastTimestamp - firstTimestamp);
            const x = xFraction * width;
            const minPrice = Math.min(...visiblePrices.map(p => p.low));
            const maxPrice = Math.max(...visiblePrices.map(p => p.high));
            const priceRange = maxPrice - minPrice;
            const y = height - (price - minPrice) / priceRange * height;
            return { x, y };
        }
        
        function placeOrder(type) {
            const orderSize = parseFloat(orderSizeInput.value);
            const limitPrice = parseFloat(limitPriceInput.value);
            const triggerPrice = parseFloat(triggerPriceInput.value);
            if (isNaN(orderSize) || orderSize <= 0) {
                alert('Please enter a valid order size.');
                return;
            }
            if (orderType === 'limit' && (isNaN(limitPrice) || limitPrice <= 0)) {
                alert('Please enter a valid limit price.');
                return;
            }
            if (orderType === 'conditional' && (isNaN(triggerPrice) || triggerPrice <= 0)) {
                alert('Please enter a valid trigger price.');
                return;
            }
            const order = {
                type,
                size: orderSize,
                leverage: currentLeverage,
                pair: displayPair,
                orderType,
                limitPrice: orderType === 'limit' ? limitPrice : null,
                triggerPrice: orderType === 'conditional' ? triggerPrice : null,
                entryPrice: currentPrice,
                timestamp: Date.now()
            };
            const requiredMargin = (orderSize / currentLeverage);
            if (availableBalance < requiredMargin) {
                alert('Insufficient balance to place this order.');
                return;
            }
            availableBalance -= requiredMargin;
            availableBalanceElement.textContent = `$${availableBalance.toFixed(2)}`;
            positions.push(order);
            updatePositionsUI();
        }
        
        function updatePositionsUI() {
            positionsContainer.innerHTML = '';
            if (positions.length === 0) {
                noPositionsMessage.style.display = 'block';
                return;
            }
            noPositionsMessage.style.display = 'none';
            positions.forEach(position => {
                const positionElement = document.createElement('div');
                positionElement.className = 'position';
                const positionHeader = document.createElement('div');
                positionHeader.className = 'position-header';
                const positionSymbol = document.createElement('div');
                positionSymbol.className = 'position-symbol';
                positionSymbol.textContent = position.pair;
                const positionType = document.createElement('div');
                positionType.className = `position-type ${position.type}`;
                positionType.textContent = position.type === 'buy' ? 'Long' : 'Short';
                positionHeader.appendChild(positionSymbol);
                positionHeader.appendChild(positionType);
                const positionDetails = document.createElement('div');
                positionDetails.className = 'position-details';
                const entryPrice = document.createElement('div');
                entryPrice.textContent = `Entry: $${position.entryPrice.toFixed(2)}`;
                const leverage = document.createElement('div');
                leverage.textContent = `Leverage: ${position.leverage}x`;
                const size = document.createElement('div');
                size.textContent = `Size: ${position.size} USDT`;
                positionDetails.appendChild(entryPrice);
                positionDetails.appendChild(leverage);
                positionDetails.appendChild(size);
                const positionPnl = document.createElement('div');
                positionPnl.className = 'position-pnl';
                const pnl = document.createElement('div');
                const currentPnl = (currentPrice - position.entryPrice) * position.size / position.entryPrice * position.leverage;
                pnl.textContent = `PnL: $${currentPnl.toFixed(2)}`;
                pnl.className = currentPnl >= 0 ? 'up' : 'down';
                const closeButton = document.createElement('button');
                closeButton.className = 'close-position';
                closeButton.textContent = 'Close';
                closeButton.addEventListener('click', () => closePosition(position));
                positionPnl.appendChild(pnl);
                positionPnl.appendChild(closeButton);
                positionElement.appendChild(positionHeader);
                positionElement.appendChild(positionDetails);
                positionElement.appendChild(positionPnl);
                positionsContainer.appendChild(positionElement);
            });
        }
        
        function closePosition(position) {
            const index = positions.indexOf(position);
            if (index !== -1) {
                positions.splice(index, 1);
                const requiredMargin = (position.size / position.leverage);
                availableBalance += requiredMargin;
                availableBalanceElement.textContent = `$${availableBalance.toFixed(2)}`;
                updatePositionsUI();
            }
        }
        
        userBalanceElement.textContent = `$${userBalance.toFixed(2)}`;
        availableBalanceElement.textContent = `$${availableBalance.toFixed(2)}`;
        priceUpdateInterval = setInterval(fetchCurrentPrice, updateInterval);
        
        function startPriceUpdates() {
            if (priceUpdateInterval) clearInterval(priceUpdateInterval);
            priceUpdateInterval = setInterval(fetchCurrentPrice, updateInterval);
        }
        
        let zoomLevel = 1;
        let panOffsetX = 0;
        let isPanning = false;
        let lastMouseX = 0;
        const MAX_ZOOM = 5;
        const MIN_ZOOM = 0.5;
        let visibleDataPoints = 100;
        const debugInfo = document.getElementById('debug-info');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const resetZoomBtn = document.getElementById('reset-zoom');
        
        function initEnhancedChart() {
            zoomInBtn.addEventListener('click', () => {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel * 1.2);
                drawChart();
            });
            zoomOutBtn.addEventListener('click', () => {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel / 1.2);
                drawChart();
            });
            resetZoomBtn.addEventListener('click', () => {
                zoomLevel = 1;
                panOffsetX = 0;
                drawChart();
            });
            chartCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoomLevel = e.deltaY < 0 ? Math.min(MAX_ZOOM, zoomLevel * 1.1) : Math.max(MIN_ZOOM, zoomLevel / 1.1);
                drawChart();
            });
            visibleDataPoints = Math.max(20, Math.floor(100 / zoomLevel));
        }
        
        function generateCandlestickData(basePrice, count = 100) {
            const candlesticks = [];
            let price = basePrice;
            for (let i = 0; i < count; i++) {
                const change = price * (Math.random() * 0.02 - 0.01) * volatilityMultiplier;
                const open = price;
                price = open + change;
                const close = price;
                const high = Math.max(open, close) * (1 + Math.random() * 0.005);
                const low = Math.min(open, close) * (1 - Math.random() * 0.005);
                candlesticks.push({
                    open,
                    high,
                    low,
                    close,
                    timestamp: Date.now() - (count - i) * 60000
                });
            }
            return candlesticks;
        }
        
        function addCrosshairTracking() {
            const verticalLine = document.createElement('div');
            verticalLine.className = 'chart-crosshair-v';
            const horizontalLine = document.createElement('div');
            horizontalLine.className = 'chart-crosshair-h';
            const priceLabel = document.createElement('div');
            priceLabel.className = 'chart-price-label';
            const chartContainer = document.querySelector('.chart');
            chartContainer.appendChild(verticalLine);
            chartContainer.appendChild(horizontalLine);
            chartContainer.appendChild(priceLabel);
            
            chartCanvas.addEventListener('mousemove', (e) => {
                const rect = chartCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                verticalLine.style.left = `${x}px`;
                verticalLine.style.display = 'block';
                horizontalLine.style.top = `${y}px`;
                horizontalLine.style.display = 'block';
                if (priceHistory.length > 0) {
                    const height = chartCanvas.height;
                    const startIdx = Math.max(0, priceHistory.length - visibleDataPoints - panOffsetX);
                    const endIdx = Math.min(priceHistory.length, startIdx + visibleDataPoints);
                    const visiblePrices = priceHistory.slice(startIdx, endIdx);
                    const minPrice = Math.min(...visiblePrices.map(p => p.low));
                    const maxPrice = Math.max(...visiblePrices.map(p => p.high));
                    const priceRange = maxPrice - minPrice;
                    const priceAtCursor = maxPrice - (y / height) * priceRange;
                    const dataPointWidth = chartCanvas.width / visiblePrices.length;
                    const dataIndex = Math.floor(x / dataPointWidth);
                    if (dataIndex >= 0 && dataIndex < visiblePrices.length) {
                        const displayPrice = visiblePrices[dataIndex].close;
                        debugInfo.textContent = `Price: $${displayPrice.toFixed(2)} at pos: ${dataIndex + startIdx}`;
                        priceLabel.textContent = `$${displayPrice.toFixed(2)}`;
                        priceLabel.style.left = `${x + 10}px`;
                        priceLabel.style.top = `${y - 20}px`;
                        priceLabel.style.display = 'block';
                    }
                }
            });
            
            chartCanvas.addEventListener('mouseleave', () => {
                verticalLine.style.display = 'none';
                horizontalLine.style.display = 'none';
                priceLabel.style.display = 'none';
            });
        }
    </script>
</body>
</html>
